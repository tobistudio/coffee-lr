---
description: Comprehensive testing patterns for Medusa applications including unit, integration, and e2e tests
globs: 
  - "**/*.test.ts"
  - "**/*.test.tsx"
  - "**/*.spec.ts"
  - "**/*.spec.tsx"
  - "**/test/**/*.ts"
  - "**/test/**/*.tsx"
  - "**/__tests__/**/*.ts"
  - "**/__tests__/**/*.tsx"
alwaysApply: true
---

# Testing Patterns for Medusa Applications

You are an expert in testing TypeScript applications, including unit tests, integration tests, and end-to-end tests for Medusa and React applications.

## Core Testing Principles

- Write tests that are readable, maintainable, and reliable
- Follow the testing pyramid: more unit tests, fewer integration tests, minimal e2e tests
- Use descriptive test names that explain the behavior being tested
- Arrange, Act, Assert (AAA) pattern for test structure
- Test behavior, not implementation details
- Use proper mocking and stubbing strategies
- Ensure tests are isolated and can run independently

## Unit Testing Patterns

### Medusa Service Testing
```typescript
// services/__tests__/UserService.test.ts
import { createMedusaContainer } from "@medusajs/framework/utils"
import { UserService } from "../UserService"
import { User } from "../models/User"

describe("UserService", () => {
  let container: MedusaContainer
  let userService: UserService
  let mockRepository: jest.Mocked<any>

  beforeEach(() => {
    container = createMedusaContainer()
    
    mockRepository = {
      create: jest.fn(),
      findOne: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    }
    
    container.register("userRepository", mockRepository)
    userService = container.resolve("userService")
  })

  describe("create", () => {
    it("should create a new user with valid data", async () => {
      // Arrange
      const userData = {
        name: "John Doe",
        email: "john@example.com",
      }
      const expectedUser = { id: "user_123", ...userData }
      mockRepository.create.mockResolvedValue(expectedUser)

      // Act
      const result = await userService.create(userData)

      // Assert
      expect(mockRepository.create).toHaveBeenCalledWith(userData)
      expect(result).toEqual(expectedUser)
    })

    it("should throw validation error for invalid email", async () => {
      // Arrange
      const invalidUserData = {
        name: "John Doe",
        email: "invalid-email",
      }

      // Act & Assert
      await expect(userService.create(invalidUserData))
        .rejects
        .toThrow("Invalid email format")
    })
  })

  describe("findById", () => {
    it("should return user when found", async () => {
      // Arrange
      const userId = "user_123"
      const expectedUser = { id: userId, name: "John Doe" }
      mockRepository.findOne.mockResolvedValue(expectedUser)

      // Act
      const result = await userService.findById(userId)

      // Assert
      expect(mockRepository.findOne).toHaveBeenCalledWith({ id: userId })
      expect(result).toEqual(expectedUser)
    })

    it("should return null when user not found", async () => {
      // Arrange
      const userId = "nonexistent"
      mockRepository.findOne.mockResolvedValue(null)

      // Act
      const result = await userService.findById(userId)

      // Assert
      expect(result).toBeNull()
    })
  })
})
```

### React Component Testing
```typescript
// components/__tests__/ProductCard.test.tsx
import { render, screen, fireEvent } from "@testing-library/react"
import { ProductCard } from "../ProductCard"
import { Product } from "../../types"

const mockProduct: Product = {
  id: "prod_123",
  title: "Test Product",
  description: "A test product",
  handle: "test-product",
  thumbnail: "/test-image.jpg",
  variants: [{
    id: "variant_123",
    prices: [{
      amount: 2000,
      currency_code: "usd",
    }],
  }],
}

describe("ProductCard", () => {
  it("renders product information correctly", () => {
    render(<ProductCard product={mockProduct} />)
    
    expect(screen.getByText("Test Product")).toBeInTheDocument()
    expect(screen.getByText("$20.00")).toBeInTheDocument()
    expect(screen.getByRole("img")).toHaveAttribute("alt", "Test Product")
  })

  it("calls onAddToCart when add to cart button is clicked", () => {
    const mockOnAddToCart = jest.fn()
    
    render(
      <ProductCard 
        product={mockProduct} 
        onAddToCart={mockOnAddToCart} 
      />
    )
    
    fireEvent.click(screen.getByText("Add to Cart"))
    
    expect(mockOnAddToCart).toHaveBeenCalledWith(mockProduct.variants[0].id)
  })

  it("displays sold out state when no variants available", () => {
    const soldOutProduct = {
      ...mockProduct,
      variants: [],
    }
    
    render(<ProductCard product={soldOutProduct} />)
    
    expect(screen.getByText("Sold Out")).toBeInTheDocument()
    expect(screen.getByRole("button")).toBeDisabled()
  })
})
```

### Hook Testing
```typescript
// hooks/__tests__/useCart.test.ts
import { renderHook, act } from "@testing-library/react"
import { useCart } from "../useCart"

// Mock the medusa SDK
jest.mock("../../lib/medusa", () => ({
  medusa: {
    store: {
      cart: {
        create: jest.fn(),
        lineItem: {
          create: jest.fn(),
          update: jest.fn(),
          delete: jest.fn(),
        },
      },
    },
  },
}))

describe("useCart", () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  it("should initialize with empty cart", () => {
    const { result } = renderHook(() => useCart())
    
    expect(result.current.items).toEqual([])
    expect(result.current.total).toBe(0)
  })

  it("should add item to cart", async () => {
    const { result } = renderHook(() => useCart())
    
    await act(async () => {
      await result.current.addItem("variant_123", 2)
    })
    
    expect(result.current.items).toHaveLength(1)
    expect(result.current.items[0].quantity).toBe(2)
  })

  it("should update item quantity", async () => {
    const { result } = renderHook(() => useCart())
    
    // Add item first
    await act(async () => {
      await result.current.addItem("variant_123", 1)
    })
    
    // Update quantity
    await act(async () => {
      await result.current.updateQuantity("line_123", 3)
    })
    
    expect(result.current.items[0].quantity).toBe(3)
  })
})
```

## Integration Testing

### API Route Testing
```typescript
// api/__tests__/products.test.ts
import { createMedusaContainer } from "@medusajs/framework/utils"
import { medusaIntegrationTestRunner } from "@medusajs/test-utils"

medusaIntegrationTestRunner({
  testSuite: ({ getContainer, api }) => {
    describe("Products API", () => {
      let container: MedusaContainer

      beforeEach(() => {
        container = getContainer()
      })

      describe("GET /admin/products", () => {
        it("should return list of products", async () => {
          // Arrange - create test data
          const productService = container.resolve("productService")
          await productService.create({
            title: "Test Product",
            handle: "test-product",
          })

          // Act
          const response = await api.get("/admin/products")

          // Assert
          expect(response.status).toBe(200)
          expect(response.data.products).toHaveLength(1)
          expect(response.data.products[0].title).toBe("Test Product")
        })

        it("should filter products by title", async () => {
          // Arrange
          const productService = container.resolve("productService")
          await productService.create({
            title: "Product A",
            handle: "product-a",
          })
          await productService.create({
            title: "Product B",
            handle: "product-b",
          })

          // Act
          const response = await api.get("/admin/products?q=Product A")

          // Assert
          expect(response.status).toBe(200)
          expect(response.data.products).toHaveLength(1)
          expect(response.data.products[0].title).toBe("Product A")
        })
      })

      describe("POST /admin/products", () => {
        it("should create a new product", async () => {
          // Arrange
          const productData = {
            title: "New Product",
            handle: "new-product",
            description: "A new product",
          }

          // Act
          const response = await api.post("/admin/products", productData)

          // Assert
          expect(response.status).toBe(201)
          expect(response.data.product.title).toBe(productData.title)
          expect(response.data.product.handle).toBe(productData.handle)
        })

        it("should return validation error for invalid data", async () => {
          // Arrange
          const invalidData = {
            title: "", // Empty title should fail validation
          }

          // Act
          const response = await api.post("/admin/products", invalidData)

          // Assert
          expect(response.status).toBe(400)
          expect(response.data.errors).toBeDefined()
        })
      })
    })
  },
})
```

### Database Integration Testing
```typescript
// modules/__tests__/UserModule.integration.test.ts
import { createMedusaContainer } from "@medusajs/framework/utils"
import { DataSource } from "typeorm"

describe("User Module Integration", () => {
  let container: MedusaContainer
  let dataSource: DataSource

  beforeAll(async () => {
    container = createMedusaContainer()
    dataSource = container.resolve("dataSource")
    await dataSource.initialize()
  })

  afterAll(async () => {
    await dataSource.destroy()
  })

  beforeEach(async () => {
    // Clean database before each test
    await dataSource.query("TRUNCATE TABLE users CASCADE")
  })

  it("should persist user data correctly", async () => {
    // Arrange
    const userService = container.resolve("userService")
    const userData = {
      name: "John Doe",
      email: "john@example.com",
    }

    // Act
    const createdUser = await userService.create(userData)
    const retrievedUser = await userService.findById(createdUser.id)

    // Assert
    expect(retrievedUser).toBeDefined()
    expect(retrievedUser!.name).toBe(userData.name)
    expect(retrievedUser!.email).toBe(userData.email)
    expect(retrievedUser!.createdAt).toBeInstanceOf(Date)
  })

  it("should handle database constraints", async () => {
    // Arrange
    const userService = container.resolve("userService")
    const userData = {
      name: "John Doe",
      email: "john@example.com",
    }

    // Act - create first user
    await userService.create(userData)

    // Assert - creating user with same email should fail
    await expect(userService.create(userData))
      .rejects
      .toThrow("Email already exists")
  })
})
```

## End-to-End Testing

### Storefront E2E Testing
```typescript
// e2e/storefront.spec.ts
import { test, expect } from "@playwright/test"

test.describe("Storefront", () => {
  test.beforeEach(async ({ page }) => {
    await page.goto("/")
  })

  test("should display products on homepage", async ({ page }) => {
    // Wait for products to load
    await page.waitForSelector("[data-testid=product-card]")
    
    // Check that products are displayed
    const productCards = page.locator("[data-testid=product-card]")
    await expect(productCards).toHaveCountGreaterThan(0)
    
    // Check product information
    const firstProduct = productCards.first()
    await expect(firstProduct.locator("h3")).toBeVisible()
    await expect(firstProduct.locator("[data-testid=product-price]")).toBeVisible()
  })

  test("should add product to cart", async ({ page }) => {
    // Navigate to product page
    await page.click("[data-testid=product-card] a")
    await page.waitForLoadState("networkidle")
    
    // Add to cart
    await page.click("[data-testid=add-to-cart-button]")
    
    // Verify cart update
    await expect(page.locator("[data-testid=cart-count]")).toHaveText("1")
    
    // Open cart drawer
    await page.click("[data-testid=cart-button]")
    
    // Verify item in cart
    await expect(page.locator("[data-testid=cart-item]")).toBeVisible()
  })

  test("should complete checkout flow", async ({ page }) => {
    // Add product to cart
    await page.click("[data-testid=product-card] a")
    await page.click("[data-testid=add-to-cart-button]")
    
    // Go to checkout
    await page.click("[data-testid=cart-button]")
    await page.click("[data-testid=checkout-button]")
    
    // Fill shipping information
    await page.fill("[name=firstName]", "John")
    await page.fill("[name=lastName]", "Doe")
    await page.fill("[name=email]", "john@example.com")
    await page.fill("[name=address]", "123 Main St")
    await page.fill("[name=city]", "New York")
    await page.fill("[name=postalCode]", "10001")
    
    // Continue to payment
    await page.click("[data-testid=continue-to-payment]")
    
    // Fill payment information (test card)
    await page.fill("[name=cardNumber]", "4242424242424242")
    await page.fill("[name=expiryDate]", "12/25")
    await page.fill("[name=cvc]", "123")
    
    // Complete order
    await page.click("[data-testid=complete-order]")
    
    // Verify success page
    await expect(page.locator("[data-testid=order-success]")).toBeVisible()
  })
})
```

## Test Utilities and Helpers

### Test Data Factories
```typescript
// test/factories/UserFactory.ts
import { faker } from "@faker-js/faker"
import { User } from "../../src/models/User"

export class UserFactory {
  static build(overrides: Partial<User> = {}): Omit<User, "id"> {
    return {
      name: faker.person.fullName(),
      email: faker.internet.email(),
      createdAt: new Date(),
      updatedAt: new Date(),
      ...overrides,
    }
  }

  static async create(
    container: MedusaContainer,
    overrides: Partial<User> = {}
  ): Promise<User> {
    const userService = container.resolve("userService")
    const userData = this.build(overrides)
    return await userService.create(userData)
  }

  static buildMany(count: number, overrides: Partial<User> = {}): Array<Omit<User, "id">> {
    return Array.from({ length: count }, () => this.build(overrides))
  }
}
```

### Custom Test Matchers
```typescript
// test/matchers.ts
import { expect } from "@jest/globals"

declare global {
  namespace jest {
    interface Matchers<R> {
      toBeValidEmail(): R
      toHaveValidTimestamps(): R
    }
  }
}

expect.extend({
  toBeValidEmail(received: string) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    const pass = emailRegex.test(received)
    
    return {
      message: () =>
        pass
          ? `Expected ${received} not to be a valid email`
          : `Expected ${received} to be a valid email`,
      pass,
    }
  },

  toHaveValidTimestamps(received: any) {
    const hasCreatedAt = received.createdAt instanceof Date
    const hasUpdatedAt = received.updatedAt instanceof Date
    const pass = hasCreatedAt && hasUpdatedAt
    
    return {
      message: () =>
        pass
          ? `Expected object not to have valid timestamps`
          : `Expected object to have valid createdAt and updatedAt timestamps`,
      pass,
    }
  },
})
```

### Mock Utilities
```typescript
// test/mocks/medusa.ts
export const createMockMedusaSDK = () => ({
  store: {
    product: {
      list: jest.fn(),
      retrieve: jest.fn(),
    },
    cart: {
      create: jest.fn(),
      retrieve: jest.fn(),
      lineItem: {
        create: jest.fn(),
        update: jest.fn(),
        delete: jest.fn(),
      },
    },
  },
  admin: {
    product: {
      list: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
  },
})

// test/mocks/services.ts
export const createMockUserService = () => ({
  create: jest.fn(),
  findById: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
  list: jest.fn(),
})
```

## Test Configuration

### Jest Configuration
```javascript
// jest.config.js
module.exports = {
  preset: "ts-jest",
  testEnvironment: "node",
  roots: ["<rootDir>/src"],
  testMatch: [
    "**/__tests__/**/*.+(ts|tsx|js)",
    "**/*.(test|spec).+(ts|tsx|js)",
  ],
  transform: {
    "^.+\\.(ts|tsx)$": "ts-jest",
  },
  collectCoverageFrom: [
    "src/**/*.{ts,tsx}",
    "!src/**/*.d.ts",
    "!src/**/*.test.{ts,tsx}",
    "!src/**/*.spec.{ts,tsx}",
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
  setupFilesAfterEnv: ["<rootDir>/test/setup.ts"],
}
```

### Test Setup
```typescript
// test/setup.ts
import "./matchers"

// Global test setup
beforeAll(() => {
  // Setup global test environment
})

afterAll(() => {
  // Cleanup global test environment
})

// Mock console methods in tests
global.console = {
  ...console,
  log: jest.fn(),
  warn: jest.fn(),
  error: jest.fn(),
}
```

## Testing Best Practices

### Test Organization
- Group related tests using `describe` blocks
- Use descriptive test names that explain the expected behavior
- Follow the AAA pattern: Arrange, Act, Assert
- Keep tests focused on a single behavior
- Use `beforeEach` and `afterEach` for test setup and cleanup

### Mocking Strategies
- Mock external dependencies and services
- Use dependency injection for easier testing
- Mock at the boundary of your system
- Avoid mocking implementation details
- Use real objects when possible (prefer fakes over mocks)

### Assertion Guidelines
- Use specific assertions that clearly express intent
- Test both positive and negative cases
- Verify error conditions and edge cases
- Use custom matchers for domain-specific assertions
- Assert on behavior, not implementation

### Performance Considerations
- Run tests in parallel when possible
- Use test databases for integration tests
- Clean up test data between tests
- Use factories for test data generation
- Optimize slow tests or move them to separate suites

Remember: Good tests serve as documentation, catch regressions, and enable confident refactoring. Write tests that are reliable, maintainable, and provide value to the development process.

